\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{enumerate}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{System Design for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
January 18, 2023 & 1.0 & Notes\\
%Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.
\subsection{Relevant Documentation}
This document references multiple other documents that are listed below:

\begin{itemize}
	\item SRS, \cite{SRS}
	\item Development Plan, \cite{DevelopmentPlan}
	\item MG, \cite{MG}
	\item MIS, \cite{MIS}
\end{itemize}

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  \progname & Explanation of program name\\
  SRS & Software Requirements Specification\\
  MG & Module Guide\\
  MIS & Module Interface Specification\\
  %\wss{...} & \wss{...}\\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}


\subsection{Document Purpose}

This series of design documents are comprised of the System Design document, 
the Module Guide, and the Module Interface Specification. The purpose of these 
documents is to communicate the modular decomposition of 
the Utrition application, and provide readers with information regarding the 
functions/methods of each module, as well as the relationships between modules. 
Information about the high-level decomposition of modules can be found in 
the \href{../SoftArchitecture/MG.pdf}{MG}.
Details regarding each module's functions and methods are discussed in 
the \href{../SoftDetailedDes/MIS.pdf}{MIS}.

\subsection{System Purpose}

The purpose of Utrition is to provide users with an application that empowers 
them to discover the nutritional value of the foods they are consuming, and track
their previously eaten meals. Utrition takes a unique approach to the traditional nutritional logging applications by providing a variety of ways for users to input their food items into the application. Users with keyboard-typing accessibility concerns will finally have a nutritional logging application that they can use without external assistance.

\wss{Users will be able to log their meals in a 
variety of ways, ranging from manual information entry, to image upload. 
Utrition will provide nutritional info based on the user's meals, and will 
allow users to access information on their past meals.}


\subsection{Scope}

Users will be able to input their food items to Utrition by using speech to text, typing, or uploading food images to the front-end user interface. If users would like to upload an image of the food they want nutritional information for, they would have to provide a photo of the food on the device using Utrition. This can be done by downloading an image of the food item from the internet, taking a photo on the device using Utrition, or by uploading a photo from the user's phone to the device using Utrition. After user input, Utrition will begin front-end and back-end calculations to obtain nutritional information for the food item from the public Nutritionix API. The nutritional information will be provided to the front-end user interface for the user to view.

\wss{Include a figure that show the System Context (showing the boundary between
your system and the environment around it.)}

\section{Project Overview}

\subsection{Normal Behaviour}

In their command-line interface, users will travel to the Utrition directory. From there, users will enter commands "npm start" and "npm run start-backend" separately. Utrition's front-end and back-end interfaces will successfully connect to the user's localhost server. Users will be greeted with the Utrition's home page. They may travel to their profile page, where they can find their past nutritional data saved in a list. On this page, users may decide to view their nutritional trends in graph form. Users may also travel to the upload page, where they can input food item(s) to find their nutritional information. Users can input food items by 
\begin{itemize}
	\item Clicking on the search bar and typing in the food items. Each food item is separated by a space.
	\item Clicking on the microphone button and verbally listing the food items.
	\item Clicking on the upload button and then selecting an image of a food item. Users can include multiple images in their search by clicking on the upload button again.
\end{itemize}
Users finalize their search by clicking the search button. In return, the user will be shown the nutritional information for each food item searched. The nutritional information is acquired from utilizing the Nutritionix public API. The data is stored on the user's device, so that past nutritional trends can be viewed on their profile page.

\subsection{Undesired Event Handling}

\wss{How you will approach undesired events}

A more in-depth look to Utrition's undesired event handling can be found in Utrition's \href{../../HazardAnalysis/HazardAnalysis.pdf}{Hazard Analysis} document.

In all cases except for one, the Utrition front-end interface will notify the user of the issue disrupting normal use of the application. Most of these errors will be detected by the back-end interface of Utrition. As a result, the application's back-end interface will send the error message to the front-end interface through the user's local server for the front-end interface to display. Certain errors, such as incorrect image type, are detected by the front-end interface and will not have to travel through the local servers to deliver the error message to the user. 

The one specific case where Utrition will not notify the user of the specific error is when Utrition closes unexpectedly. The cause of this rare issue is unknown to the developers, but the application will save its data periodically during use to ensure not much information is lost from the crash.

\subsection{Component Diagram}

\subsection{\href{../../SRS/SRS.pdf}{Connection Between Requirements and Design}} \label{SecConnection}

\wss{The intention of this section is to document decisions that are made
  ``between'' the requirements and the design.  To satisfy some requirements,
  design decisions need to be made.  Rather than make these decisions implicit,
  they are explicitly recorded here.  For instance, if a program has security
  requirements, a specific design decision may be made to satisfy those
  requirements with a password.}

\subsubsection{Functional Requirements}

\begin{enumerate}[{FR}1. ]
	\item Provide user a screen with the option to click a button, which then leads the user to upload an image.
	\item Provide the user a button to click on that allows them to enter another food item. After the second food item is entered, the button remains for more food items to be entered.
	\item The food item(s) uploaded to the Utrition frontend will be condensed to a 32x32 pixel image, which is then turned into a 32x32 array. The array containing data for each pixel is then transferred to the Utrition backend. From there, the image is parsed through a TensorFlow machine learning algorithm which is trained on the CIFAR-100 dataset to determine the food item.
	\item The Utrition backend provides the Nutritionix API with valid headers (x-app-id, x-app-key, x-remote-user-id) that allow the use of the API.
	\item The Utrition backend interface sends a POST request to the Nutritionix API. The response to the POST request provides the backend interface with a JSON file containing the food’s macro-nutrients, micro-nutrients, and caloric details.
	\item Once the Utrition backend has received the nutritional details of the food item from the Nutritionix API, the backend stores the nutritional information as a JSON file on the users’ Utrition folder.
	\item Once the user requests to see past nutritional data, the frontend interface sends a GET request to the frontend local server. This request is passed to the backend local server, which then gets sent to the backend interface. The backend interface returns the data of all logged JSON files in the previously logged food items folder to the front-end interface (going through their respective local servers). The frontend interface displays the JSON files’ data in reverse-chronological order.
	\item Once the Utrition backend interface receives the JSON file from the Nutritionix API, the data is sent to the local backend server, to the local frontend server, and then to the frontend interface. In the frontend interface, the JSON file has the “stringify” method applied to it to display the information to the user.
	\item Once the user requests to see the past nutritional data graph, the frontend interface switches to a different user interface screen. From there, the front end interface sends a GET request to the frontend local server. This request is passed to the backend local server, which then gets sent to the backend interface. The backend interface returns the data of all logged JSON files in the previously logged food items folder to the front-end interface (going through their respective local servers). The frontend interface parses the data by using ChartJS to display a graph of past nutritional trends to the user.
	
	
\end{enumerate}

\section{System Variables}

\wss{Include this section for Mechatronics projects}

\subsection{Monitored Variables}

N/A

\subsection{Controlled Variables}

N/A

\subsection{Constants Variables}

N/A

\section{User Interfaces}

\wss{Design of user interface for software and hardware.  Attach an appendix if
needed. Drawings, Sketches, Figma}

\section{Design of Hardware}

\wss{Most relevant for mechatronics projects}
\wss{Show what will be acquired}
\wss{Show what will be built, with detail on fabrication and materials}
\wss{Include appendices as appropriate, possibly with sketches, drawings, CAD, 
etc}

N/A

\section{Design of Electrical Components}

\wss{Most relevant for mechatronics projects}
\wss{Show what will be acquired}
\wss{Show what will be built, with detail on fabrication and materials}
\wss{Include appendices as appropriate, possibly with sketches, drawings,
circuit diagrams, etc}

N/A

\section{Design of Communication Protocols}

\wss{If appropriate}

Front/Backend

\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\appendix

\section{Interface}

\wss{Include additional information related to the appearance of, and
interaction with, the user interface}

\section{Mechanical Hardware}

N/A

\section{Electrical Components}

N/A

\section{Communication Protocols}

\section{Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.  Please answer the following questions:

\begin{enumerate}
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select documented design?
  (LO\_Explores)
\end{enumerate}

\end{document}